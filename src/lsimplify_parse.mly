%{
(* auto-generated by gt *)

   open Lsimplify_syntax;;
   open Ast;;

   (* 1. Parse into AST with sym_table id's, and root node identified
    * 2. Flatten (unfold) node calls in expressions that are supposed
    *    to be const (array indices, etc.)
    * 3. Unfold constant expressions
    * 4. Expand node calls
    * 5. Expand tuples
    *)

let parse_error s =
	 let error = s^" in "^(!Lsimplify_util.file)^" on line "^(string_of_int (!Lsimplify_util.line))^"" in failwith error;;
%}

%start main

%token EOF AND ARROW ASSERT COLON COMMA CONST CURRENT DIAMOND DIV DOTDOT ELSE EQUALS FUNCTION GREATERTHAN GTEQUALS IF IMPLIES INCLUDE KINDCOMM LEFTPAREN LEFTSQUARE LESSTHAN LET LTEQUALS MINUS MOD NODE NOT OR PIPE PLUS POUND PRE RETURNS RIGHTPAREN RIGHTSQUARE SEMICOLON SLASH STAR STEP TEL THEN TYPE UPCARAT VAR WHEN WITH XOR
%token <string> IDENTIFIER INTEGER REAL STRINGLIT
%left LEFTSQUARE WHEN ELSE
%left UPCARAT
%left IMPLIES
%left OR
%left XOR
%left AND
%left EQUALS DIAMOND
%nonassoc GREATERTHAN GTEQUALS LESSTHAN LTEQUALS
%left PLUS MINUS
%left STAR SLASH MOD DIV PIPE ARROW
%nonassoc UMINUS NOT CURRENT PRE

%type <Lsimplify_syntax.program option> main
%type <Lsimplify_syntax.body> body
%type <Lsimplify_syntax.body_end> body_end
%type <Lsimplify_syntax.clocked_var_decl> clocked_var_decl
%type <Lsimplify_syntax.const_decl> const_decl
%type <Lsimplify_syntax.constdecl_const_decl_one_const_decl7> constdecl_const_decl_one_const_decl7
%type <Lsimplify_syntax.equation> equation
%type <Lsimplify_syntax.equation2_equation_exp11> equation2_equation_exp11
%type <Lsimplify_syntax.equation_list> equation_list
%type <Lsimplify_syntax.equationlist_equation_list_equation13> equationlist_equation_list_equation13
%type <Lsimplify_syntax.exp> exp
%type <Lsimplify_syntax.exp_list> exp_list

%type <Lsimplify_syntax.explist_exp_list_comma49> explist_exp_list_comma49

%type <Lsimplify_syntax.func_decl> func_decl
%type <Lsimplify_syntax.id_list> id_list
%type <Lsimplify_syntax.in_param> in_param
%type <Lsimplify_syntax.in_param_list> in_param_list
%type <Lsimplify_syntax.include_list> include_list
%type <Lsimplify_syntax.includelist_include_list_linclude58> includelist_include_list_linclude58
%type <Lsimplify_syntax.inparamlist_in_param_list_semicolon56> inparamlist_in_param_list_semicolon56
%type <Lsimplify_syntax.left_elem> left_elem
%type <Lsimplify_syntax.left_elem_list> left_elem_list
%type <Lsimplify_syntax.left_part> left_part
%type <Lsimplify_syntax.leftelemlist_left_elem_list_comma63> leftelemlist_left_elem_list_comma63
%type <Lsimplify_syntax.linclude> linclude
%type <Lsimplify_syntax.local_decl> local_decl
%type <Lsimplify_syntax.localdecl_local_decl_clocked_var_decl68> localdecl_local_decl_clocked_var_decl68
%type <Lsimplify_syntax.ltype> ltype
%type <Lsimplify_syntax.ltype_list> ltype_list
%type <Lsimplify_syntax.ltypelist_ltype_list_comma73> ltypelist_ltype_list_comma73

%type <Lsimplify_syntax.lus_file> lus_file

%type <Lsimplify_syntax.lusfile_lus_file_one_decl75> lusfile_lus_file_one_decl75

%type <Lsimplify_syntax.node_decl> node_decl
%type <Lsimplify_syntax.nodedecl_node_decl_local_decl77> nodedecl_node_decl_local_decl77
%type <Lsimplify_syntax.one_const_decl> one_const_decl
%type <Lsimplify_syntax.one_decl> one_decl
%type <Lsimplify_syntax.one_type_decl> one_type_decl
%type <Lsimplify_syntax.program> program
%type <Lsimplify_syntax.sel_sub> sel_sub
%type <Lsimplify_syntax.sel_subsub> sel_subsub
%type <Lsimplify_syntax.selector> selector
%type <Lsimplify_syntax.selsub_sel_sub_dotdot88> selsub_sel_sub_dotdot88
%type <Lsimplify_syntax.selsubsub_sel_subsub_step90> selsubsub_sel_subsub_step90
%type <Lsimplify_syntax.struct_filter> struct_filter
%type <Lsimplify_syntax.tab_access> tab_access
%type <Lsimplify_syntax.type_decl> type_decl
%type <Lsimplify_syntax.type_list> type_list
%type <Lsimplify_syntax.typedecl_type_decl_one_type_decl96> typedecl_type_decl_one_type_decl96
%type <Lsimplify_syntax.typelist_type_list_comma98> typelist_type_list_comma98
%type <Lsimplify_syntax.var_decl> var_decl
%type <Lsimplify_syntax.var_decl_list> var_decl_list

%type <Lsimplify_syntax.vardecllist_var_decl_list_semicolon101> vardecllist_var_decl_list_semicolon101

%type <Lsimplify_syntax.varlist_id_list_comma52> varlist_id_list_comma52

%type <Lsimplify_util.pd> cur_position

%%

main:
| program { Some($1) }
| EOF { None }

cur_position:
| { Lsimplify_util.cur_pd() }

body:
| cur_position LET equation_list TEL body_end { Body($1, $3, $5) }

body_end:
| cur_position { NoBodyEnd($1) }

body_end:
| cur_position SEMICOLON { BodyEnd($1) }

clocked_var_decl:
| var_decl {
   (* DECLARE VAR SYMBOLS *)
   ClockedVarDecl(pd_var_decl $1, $1)
}

clocked_var_decl:
| cur_position LEFTPAREN var_decl_list RIGHTPAREN WHEN IDENTIFIER {
   (* DECLARE VAR SYMBOLS *)
   (* ADD VAR SYM *)
   let id = (add_sym $6 AllScope) in
   WhenClockedVarDecl($1, $3, id)
}

const_decl:
| cur_position CONST constdecl_const_decl_one_const_decl7 {
   (* DECLARE SYMBOLS 0 *)
   finish_scope 0;
   ConstDecl($1, $3)
}

equation:
| cur_position ASSERT exp { AssertEquation($1, $3) }

equation:
| left_part EQUALS exp { AssignEquation(pd_left_part $1, $1, $3) }

equation:
| cur_position KINDCOMM IDENTIFIER COLON equation2_equation_exp11 {
   (*print_string "T";*)
   let id = add_sym $3 AllScope in
   (*print_int id;*)
   if id=kcomm_main then root_node_flag := true;
   KindEquation($1, id, $5)
}

equation_list:
| equationlist_equation_list_equation13 { EquationList(pd_equationlist_equation_list_equation13 $1, $1) }

exp:
| cur_position INTEGER { IntExp($1, int_of_string $2) }

exp:
| cur_position REAL { RealExp($1, float_of_string $2) }

exp:
| cur_position IDENTIFIER {
   let _ = (Lsimplify_util.string_of_pos (fst $1))^" of "^(!Lsimplify_util.file) in
   (* ADD VAR SYM *)
   let id = add_sym $2 AllScope in
   (*print_string ("Parser found variable name '");
   print_string $2;
   print_string "',";
   print_int !current_node_id;
   print_string " on ";
   print_string loc;
   print_string " as VARID=";
   print_string (string_of_int id);
   print_string "\n";*)
   IdExp($1, id)
}

exp:
| cur_position IDENTIFIER LEFTPAREN exp_list RIGHTPAREN {
   let _ = (Lsimplify_util.string_of_pos (fst $1))^" of "^(!Lsimplify_util.file) in
   (* ADD NODE SYM *)
   let id = add_sym $2 AllScope in
   (*print_string "Parser found node instantiation '";
   print_string $2;
   print_string "' on ";
   print_string loc;
   print_string " as NODEID=";
   print_string (string_of_int id);
   print_string "\n";*)
   NodeExp($1, id, $4) }

exp:
| cur_position LEFTPAREN exp_list RIGHTPAREN { ListExp($1, $3) }

exp:
| cur_position LEFTSQUARE exp_list RIGHTSQUARE { TupleExp($1, $3) }

exp:
| cur_position NOT exp { NotExp($1, $3) }

exp:
| cur_position MINUS exp %prec UMINUS { NegExp($1, $3) }

exp:
| cur_position PRE exp { PreExp($1, $3) }

exp:
| cur_position CURRENT exp { CurrentExp($1, $3) }

exp:
| exp ARROW exp { ArrowExp(pd_exp $1, $1, $3) }

exp:
| exp WHEN exp { WhenExp(pd_exp $1, $1, $3) }

exp:
| exp OR exp { OrExp(pd_exp $1, $1, $3) }

exp:
| exp XOR exp { XorExp(pd_exp $1, $1, $3) }

exp:
| exp AND exp { AndExp(pd_exp $1, $1, $3) }

exp:
| exp IMPLIES exp { ImpExp(pd_exp $1, $1, $3) }

exp:
| exp EQUALS exp { EqExp(pd_exp $1, $1, $3) }

exp:
| exp DIAMOND exp { DiamondExp(pd_exp $1, $1, $3) }

exp:
| exp LESSTHAN exp { LtExp(pd_exp $1, $1, $3) }

exp:
| exp GREATERTHAN exp { GtExp(pd_exp $1, $1, $3) }

exp:
| exp LTEQUALS exp { LteExp(pd_exp $1, $1, $3) }

exp:
| exp GTEQUALS exp { GteExp(pd_exp $1, $1, $3) }

exp:
| exp PLUS exp { PlusExp(pd_exp $1, $1, $3) }

exp:
| exp MINUS exp { MinusExp(pd_exp $1, $1, $3) }

exp:
| exp STAR exp { StarExp(pd_exp $1, $1, $3) }

exp:
| exp SLASH exp { SlashExp(pd_exp $1, $1, $3) }

exp:
| exp DIV exp { DivExp(pd_exp $1, $1, $3) }

exp:
| exp MOD exp { ModExp(pd_exp $1, $1, $3) }

exp:
| exp UPCARAT exp { ArrayExp(pd_exp $1, $1, $3) }

exp:
| exp PIPE exp { ConcatExp(pd_exp $1, $1, $3) }

exp:
| exp LEFTSQUARE exp sel_sub RIGHTSQUARE { SliceExp(pd_exp $1, $1, $3, $4) }

exp:
| cur_position IF exp THEN exp ELSE exp { IfExp($1, $3, $5, $7) }

exp:
| cur_position WITH exp THEN exp ELSE exp { WithExp($1, $3, $5, $7) }

exp:
| cur_position POUND LEFTPAREN exp_list RIGHTPAREN { PoundExp($1, $4) }

exp_list:
| exp explist_exp_list_comma49 { ExpList(pd_exp $1, $1, $2) }

func_decl:
| cur_position FUNCTION IDENTIFIER LEFTPAREN var_decl_list RIGHTPAREN RETURNS
LEFTPAREN var_decl_list RIGHTPAREN {
      (* DECLARE VAR SYMBOLS *)

      (* DECLARE VAR SYMBOLS *)

   (* ADD FUNC SYM *)
   let id = add_sym $3 AllScope in
   finish_scope id;
   (* DECLARE SYMBOLS id *)
   (* DECLARE FUNC SYMBOL *)
   (* DECLARE SYMBOLS 0 *)
   FuncDecl($1, id, $5, $9)
}

id_list:
| cur_position IDENTIFIER varlist_id_list_comma52 {
   (* ADD VAR SYM *)
   VarList($1, (add_sym $2 AllScope), ($3))
}

new_id_list:
| cur_position IDENTIFIER varlist_id_list_comma53 {
   (* ADD VAR SYM *)
   VarList($1, (add_sym $2 NoScope), ($3))
}

in_param:
| clocked_var_decl { InParam(pd_clocked_var_decl $1, $1) }

in_param:
| cur_position CONST var_decl {
   (* DECLARE VAR SYMBOLS *)
   ConstInParam($1, $3)
}

in_param_list:
| in_param inparamlist_in_param_list_semicolon56 { InParamList(pd_in_param $1, $1, $2) }

include_list:
| includelist_include_list_linclude58 { IncludeList(pd_includelist_include_list_linclude58 $1, $1) }

left_elem:
| cur_position IDENTIFIER {
   (* ADD VAR SYM *)
   IdLeftElem($1, add_sym $2 AllScope)
}

left_elem:
| struct_filter { StructLeftElem(pd_struct_filter $1, $1) }

left_elem:
| tab_access { SliceLeftElem(pd_tab_access $1, $1) }

left_elem_list:
| left_elem leftelemlist_left_elem_list_comma63 { LeftElemList(pd_left_elem $1, $1, $2) }

left_part:
| left_elem_list { LeftPart(pd_left_elem_list $1, $1) }

left_part:
| cur_position LEFTPAREN left_elem_list RIGHTPAREN { ParenLeftPart($1, $3) }

linclude:
| cur_position INCLUDE STRINGLIT { Include($1, $3) }

local_decl:
| cur_position VAR localdecl_local_decl_clocked_var_decl68 { LocalDecl($1, $3) }

ltype:
| cur_position IDENTIFIER { 
   let _ = (Lsimplify_util.string_of_pos (fst $1))^" of "^(!Lsimplify_util.file) in
   (* ADD TYPE SYM *)
   let id = add_sym $2 AllScope in
   (*print_string ("Parser found type name '");
   print_string $2;
   print_string "' on ";
   print_string loc;
   print_string " as TYPEID=";
   print_string (string_of_int id);
   print_string "\n";*)
   (*declare_types id;*)
   IdType($1, id)
}

ltype:
| ltype UPCARAT exp { ArrayType(pd_ltype $1, $1, $3) }

ltype:
| cur_position LEFTSQUARE type_list RIGHTSQUARE { StructType($1, $3) }

ltype_list:
| cur_position IDENTIFIER ltypelist_ltype_list_comma73 {
   (* ADD TYPE SYM *)
   let id = add_sym $2 AllScope in
   LTypeList($1,id,($3))
}

lus_file:
| lusfile_lus_file_one_decl75 { LusFile(pd_lusfile_lus_file_one_decl75 $1, $1) }

node_decl:
| cur_position NODE IDENTIFIER LEFTPAREN in_param_list RIGHTPAREN RETURNS
LEFTPAREN in_param_list RIGHTPAREN SEMICOLON
nodedecl_node_decl_local_decl77 body {
let _ = (Lsimplify_util.string_of_pos (fst $1))^" of "^(!Lsimplify_util.file) in
   (* ADD NODE SYM *)
   let id = add_sym $3 GlobalScope in
   finish_scope id;
   (* declare_symbols id; *)
         (* DECLARE NODE SYMBOL *)
   (* declare_symbols 0; *)

   (*print_string ("Parser found node declaration '");
   print_string $3;
   print_string "' on ";
   print_string loc;
   print_string " as NODEID=";
   print_string (string_of_int id);
   print_string "\n";*)
   if !root_node_flag then (
      root_node_flag := false;
      root_node := id
   );
   let n = NodeDecl($1, id, $5, $9, $12, $13) in
   (*let exist = store_node id (ref n) in
   if exist then failwith ("redeclaration of node '"^$3^"' on "^loc);*)
      (*print_string ">>>PARSENODE: ";
      print_string $3;
      print_string ", ";
      print_int !Ast.current_node_id;
      print_string ", ";
      print_int !Ast.node_count;*)

   (*current_node_id := 0;*)

   (*print_string " = ";
   print_int !Ast.current_node_id;
   print_string ", ";
   print_int !Ast.node_count;
   print_string "\n";*)
   n
}

one_const_decl:
| cur_position IDENTIFIER EQUALS exp {
   (* ADD VAR SYM *)
   let id = add_sym $2 AllScope in
   (* DECLARE VAR SYMBOLS *)
   EqOneConstDecl($1, id, $4)
}

one_const_decl:
| id_list COLON IDENTIFIER {
   (* ADD TYPE SYM *)
   let id = add_sym $3 AllScope in
   (* DECLARE VAR SYMBOLS *)
   (*declare_types id;*)
   ListOneConstDecl(pd_id_list $1, $1, id)
}

one_decl:
| const_decl { ConstOneDecl(pd_const_decl $1, $1) }

one_decl:
| type_decl { TypeOneDecl(pd_type_decl $1, $1) }

one_decl:
| func_decl { FuncOneDecl(pd_func_decl $1, $1) }

one_decl:
| node_decl { NodeOneDecl(pd_node_decl $1, $1) }

one_type_decl:
| cur_position IDENTIFIER EQUALS ltype {
   let _ = (Lsimplify_util.string_of_pos (fst $1))^" of "^(!Lsimplify_util.file) in
   (* ADD TYPE SYM *)
   let id = add_sym $2 AllScope in
   (* DECLARE TYPE SYMBOLS *)
   (*print_string ("Parser found type declaration '");
   print_string $2;
   print_string "' on ";
   print_string loc;
   print_string " as TYPEID=";
   print_string (string_of_int id);
   print_string "\n";*)
   EqOneTypeDecl($1, id, $4)
}

one_type_decl:
| ltype_list {
   (* DECLARE TYPE SYMBOLS *)
   ListOneTypeDecl(pd_ltype_list $1, $1)
}

program:
| include_list lus_file { Program(pd_include_list $1, $1, $2) }

sel_sub:
| selsub_sel_sub_dotdot88 { SelSub(pd_selsub_sel_sub_dotdot88 $1, $1) }

sel_subsub:
| selsubsub_sel_subsub_step90 { SelSubSub(pd_selsubsub_sel_subsub_step90 $1, $1) }

selector:
| cur_position LEFTSQUARE exp sel_sub RIGHTSQUARE { Selector($1, $3, $4) }

struct_filter:
| cur_position LEFTSQUARE left_elem_list RIGHTSQUARE { StructFilter($1, $3) }

tab_access:
| cur_position IDENTIFIER selector {
   (* ADD VAR SYM *)
   TabAccess($1, add_sym $2 AllScope, $3)
}

tab_access:
| tab_access selector { MultiTabAccess(pd_tab_access $1, $1, $2) }

type_decl:
| cur_position TYPE typedecl_type_decl_one_type_decl96 {
   (* declare_symbols 0; *)
   finish_scope 0;
   TypeDecl($1, $3)
}

type_list:
| ltype typelist_type_list_comma98 { TypeList(pd_ltype $1, $1, $2) }

var_decl:
| new_id_list COLON ltype { VarDecl(pd_id_list $1, $1, $3) }

var_decl_list:
| var_decl vardecllist_var_decl_list_semicolon101 { VarDeclList(pd_var_decl $1, $1, $2) }

vardecllist_var_decl_list_semicolon101:
| cur_position { ($1, []) }

vardecllist_var_decl_list_semicolon101:
| cur_position SEMICOLON var_decl vardecllist_var_decl_list_semicolon101 { let (p, ( l2 )) = $4 in ($1, ($3)::(l2)) }

typelist_type_list_comma98:
| cur_position { ($1, []) }

typelist_type_list_comma98:
| cur_position COMMA ltype typelist_type_list_comma98 { let (p, ( l2 )) = $4 in ($1, ($3)::(l2)) }

typedecl_type_decl_one_type_decl96:
| one_type_decl SEMICOLON { (pd_one_type_decl $1, ($1)::[]) }

typedecl_type_decl_one_type_decl96:
| one_type_decl SEMICOLON typedecl_type_decl_one_type_decl96 { let (p, ( l1 )) = $3 in (pd_one_type_decl $1, ($1)::(l1)) }

selsubsub_sel_subsub_step90:
| cur_position STEP exp { ($1, Some( $3 )) }

selsubsub_sel_subsub_step90:
| cur_position { ($1, None) }

selsub_sel_sub_dotdot88:
| cur_position DOTDOT exp sel_subsub { ($1, Some( $3 , $4)) }

selsub_sel_sub_dotdot88:
| cur_position { ($1, None) }

nodedecl_node_decl_local_decl77:
| local_decl { (pd_local_decl $1, Some( $1 )) }

nodedecl_node_decl_local_decl77:
| cur_position { ($1, None) }

lusfile_lus_file_one_decl75:
| cur_position {
   ($1, [], [], [], [])
}

lusfile_lus_file_one_decl75:
| one_decl lusfile_lus_file_one_decl75 {
   let (p,tl,cl,fl,nl) = $2 in
   (match $1 with
   | ConstOneDecl(_,cd) -> (p, tl, cd::cl, fl, nl)
   | TypeOneDecl(_,td) -> (p, td::tl, cl, fl, nl)
   | FuncOneDecl(_,fd) -> (p, tl, cl, fd::fl, nl)
   | NodeOneDecl(_,nd) -> (p, tl, cl, fl, nd::nl)
   )
}

ltypelist_ltype_list_comma73:
| cur_position { ($1, []) }

ltypelist_ltype_list_comma73:
| cur_position COMMA IDENTIFIER ltypelist_ltype_list_comma73 {
   (* ADD TYPE SYM *)
   let id = add_sym $3 AllScope in
   let (p, ( l2 )) = $4 in ($1, id::(l2))
}

localdecl_local_decl_clocked_var_decl68:
| clocked_var_decl SEMICOLON { (pd_clocked_var_decl $1, ($1)::[]) }

localdecl_local_decl_clocked_var_decl68:
| clocked_var_decl SEMICOLON localdecl_local_decl_clocked_var_decl68 { let (p, ( l1 )) = $3 in (pd_clocked_var_decl $1, ($1)::(l1)) }

leftelemlist_left_elem_list_comma63:
| cur_position { ($1, []) }

leftelemlist_left_elem_list_comma63:
| cur_position COMMA left_elem leftelemlist_left_elem_list_comma63 { let (p, ( l2 )) = $4 in ($1, ($3)::(l2)) }

includelist_include_list_linclude58:
| cur_position { ($1, []) }

includelist_include_list_linclude58:
| linclude includelist_include_list_linclude58 { let (p, ( l1 )) = $2 in (pd_linclude $1, ($1)::(l1)) }

inparamlist_in_param_list_semicolon56:
| cur_position { ($1, []) }

inparamlist_in_param_list_semicolon56:
| cur_position SEMICOLON in_param inparamlist_in_param_list_semicolon56 { let (p, ( l2 )) = $4 in ($1, ($3)::(l2)) }

varlist_id_list_comma52:
| cur_position { ($1, []) }

varlist_id_list_comma52:
| cur_position COMMA IDENTIFIER varlist_id_list_comma52 {
   let (p, ( l2 )) = $4 in
   (* ADD VAR SYM *)
   ($1, (add_sym $3 AllScope)::(l2))
}

varlist_id_list_comma53:
| cur_position { ($1, []) }

varlist_id_list_comma53:
| cur_position COMMA IDENTIFIER varlist_id_list_comma53 {
   let (p, ( l2 )) = $4 in
   (* ADD VAR SYM *)
   ($1, (add_sym $3 NoScope)::(l2))
}

explist_exp_list_comma49:
| cur_position { ($1, []) }

explist_exp_list_comma49:
| cur_position COMMA exp explist_exp_list_comma49 { let (p, ( l2 )) = $4 in ($1, ($3)::(l2)) }

equationlist_equation_list_equation13:
| equation SEMICOLON { (pd_equation $1, ($1)::[]) }

equationlist_equation_list_equation13:
| equation SEMICOLON equationlist_equation_list_equation13 { let (p, ( l1 )) = $3 in (pd_equation $1, ($1)::(l1)) }

equation2_equation_exp11:
| exp { (pd_exp $1, Some( $1 )) }

equation2_equation_exp11:
| cur_position { ($1, None) }

constdecl_const_decl_one_const_decl7:
| one_const_decl SEMICOLON { (pd_one_const_decl $1, ($1)::[]) }

constdecl_const_decl_one_const_decl7:
| one_const_decl SEMICOLON constdecl_const_decl_one_const_decl7 { let (p, ( l1 )) = $3 in (pd_one_const_decl $1, ($1)::(l1)) }
